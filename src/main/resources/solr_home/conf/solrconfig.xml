<?xml version="1.0" encoding="UTF-8" ?>
<config>

    <luceneMatchVersion>4.4</luceneMatchVersion>


    <lib dir="../../../contrib/extraction/lib" regex=".*\.jar"/>
    <lib dir="../../../dist/" regex="solr-cell-\d.*\.jar"/>

    <lib dir="../../../contrib/clustering/lib/" regex=".*\.jar"/>
    <lib dir="../../../dist/" regex="solr-clustering-\d.*\.jar"/>

    <lib dir="../../../contrib/langid/lib/" regex=".*\.jar"/>
    <lib dir="../../../dist/" regex="solr-langid-\d.*\.jar"/>

    <lib dir="../../../contrib/velocity/lib" regex=".*\.jar"/>
    <lib dir="../../../dist/" regex="solr-velocity-\d.*\.jar"/>


    <dataDir>${solr.data.dir:}</dataDir>


    <directoryFactory name="DirectoryFactory"
                      class="${solr.directoryFactory:solr.NRTCachingDirectoryFactory}"/>


    <codecFactory class="solr.SchemaCodecFactory"/>


    <schemaFactory class="ClassicIndexSchemaFactory"/>

    <indexConfig>
        <lockType>${solr.lock.type:native}</lockType>

        <infoStream>true</infoStream>
    </indexConfig>


    <jmx/>

    <updateHandler class="solr.DirectUpdateHandler2">


        <updateLog>
            <str name="dir">${solr.ulog.dir:}</str>
        </updateLog>


        <autoCommit>
            <maxTime>${solr.autoCommit.maxTime:15000}</maxTime>
            <openSearcher>false</openSearcher>
        </autoCommit>
        <autoSoftCommit>
            <maxTime>${solr.autoSoftCommit.maxTime:-1}</maxTime>
        </autoSoftCommit>


    </updateHandler>


    <query>
        <maxBooleanClauses>1024</maxBooleanClauses>


        <filterCache class="solr.FastLRUCache"
                     size="512"
                     initialSize="512"
                     autowarmCount="0"/>

        <queryResultCache class="solr.LRUCache"
                          size="512"
                          initialSize="512"
                          autowarmCount="0"/>


        <documentCache class="solr.LRUCache"
                       size="512"
                       initialSize="512"
                       autowarmCount="0"/>


        <enableLazyFieldLoading>true</enableLazyFieldLoading>


        <queryResultWindowSize>20</queryResultWindowSize>


        <queryResultMaxDocsCached>200</queryResultMaxDocsCached>

        <listener event="newSearcher" class="solr.QuerySenderListener">
            <arr name="queries">
            </arr>
        </listener>
        <listener event="firstSearcher" class="solr.QuerySenderListener">
            <arr name="queries">
                <lst>
                    <str name="q">static firstSearcher warming in solrconfig.xml</str>
                </lst>
            </arr>
        </listener>

        <useColdSearcher>false</useColdSearcher>

        <maxWarmingSearchers>2</maxWarmingSearchers>

    </query>
    <requestDispatcher handleSelect="false">

        <requestParsers enableRemoteStreaming="true"
                        multipartUploadLimitInKB="2048000"
                        formdataUploadLimitInKB="2048"
                        addHttpRequestToContext="false"/>

        <httpCaching never304="true"/>
    </requestDispatcher>


    <requestHandler name="/select" class="solr.SearchHandler">

        <lst name="defaults">
            <str name="echoParams">explicit</str>
            <int name="rows">10</int>
            <str name="df">text</str>
        </lst>

    </requestHandler>

    <requestHandler name="/query" class="solr.SearchHandler">
        <lst name="defaults">
            <str name="echoParams">explicit</str>
            <str name="wt">json</str>
            <str name="indent">true</str>
            <str name="df">text</str>
        </lst>
    </requestHandler>

    <requestHandler name="/get" class="solr.RealTimeGetHandler">
        <lst name="defaults">
            <str name="omitHeader">true</str>
            <str name="wt">json</str>
            <str name="indent">true</str>
        </lst>
    </requestHandler>


    <requestHandler name="/browse" class="solr.SearchHandler">
        <lst name="defaults">
            <str name="echoParams">explicit</str>

            <!-- VelocityResponseWriter settings -->
            <str name="wt">velocity</str>
            <str name="v.template">browse</str>
            <str name="v.layout">layout</str>
            <str name="title">Solritas</str>

            <!-- Query settings -->
            <str name="defType">edismax</str>
            <str name="qf">
                text^0.5 features^1.0 name^1.2 sku^1.5 id^10.0 manu^1.1 cat^1.4
                title^10.0 description^5.0 keywords^5.0 author^2.0 resourcename^1.0
            </str>
            <str name="df">text</str>
            <str name="mm">100%</str>
            <str name="q.alt">*:*</str>
            <str name="rows">10</str>
            <str name="fl">*,score</str>

            <str name="mlt.qf">
                text^0.5 features^1.0 name^1.2 sku^1.5 id^10.0 manu^1.1 cat^1.4
                title^10.0 description^5.0 keywords^5.0 author^2.0 resourcename^1.0
            </str>
            <str name="mlt.fl">text,features,name,sku,id,manu,cat,title,description,keywords,author,resourcename</str>
            <int name="mlt.count">3</int>

            <!-- Faceting defaults -->
            <str name="facet">on</str>
            <str name="facet.field">cat</str>
            <str name="facet.field">manu_exact</str>
            <str name="facet.field">content_type</str>
            <str name="facet.field">author_s</str>
            <str name="facet.query">ipod</str>
            <str name="facet.query">GB</str>
            <str name="facet.mincount">1</str>
            <str name="facet.pivot">cat,inStock</str>
            <str name="facet.range.other">after</str>
            <str name="facet.range">price</str>
            <int name="f.price.facet.range.start">0</int>
            <int name="f.price.facet.range.end">600</int>
            <int name="f.price.facet.range.gap">50</int>
            <str name="facet.range">popularity</str>
            <int name="f.popularity.facet.range.start">0</int>
            <int name="f.popularity.facet.range.end">10</int>
            <int name="f.popularity.facet.range.gap">3</int>
            <str name="facet.range">manufacturedate_dt</str>
            <str name="f.manufacturedate_dt.facet.range.start">NOW/YEAR-10YEARS</str>
            <str name="f.manufacturedate_dt.facet.range.end">NOW</str>
            <str name="f.manufacturedate_dt.facet.range.gap">+1YEAR</str>
            <str name="f.manufacturedate_dt.facet.range.other">before</str>
            <str name="f.manufacturedate_dt.facet.range.other">after</str>

            <!-- Highlighting defaults -->
            <str name="hl">on</str>
            <str name="hl.fl">content features title name</str>
            <str name="hl.encoder">html</str>
            <str name="hl.simple.pre">&lt;b&gt;</str>
            <str name="hl.simple.post">&lt;/b&gt;</str>
            <str name="f.title.hl.fragsize">0</str>
            <str name="f.title.hl.alternateField">title</str>
            <str name="f.name.hl.fragsize">0</str>
            <str name="f.name.hl.alternateField">name</str>
            <str name="f.content.hl.snippets">3</str>
            <str name="f.content.hl.fragsize">200</str>
            <str name="f.content.hl.alternateField">content</str>
            <str name="f.content.hl.maxAlternateFieldLength">750</str>

            <!-- Spell checking defaults -->
            <str name="spellcheck">on</str>
            <str name="spellcheck.extendedResults">false</str>
            <str name="spellcheck.count">5</str>
            <str name="spellcheck.alternativeTermCount">2</str>
            <str name="spellcheck.maxResultsForSuggest">5</str>
            <str name="spellcheck.collate">true</str>
            <str name="spellcheck.collateExtendedResults">true</str>
            <str name="spellcheck.maxCollationTries">5</str>
            <str name="spellcheck.maxCollations">3</str>
        </lst>

        <!-- append spellchecking to our list of components -->
        <arr name="last-components">
            <str>spellcheck</str>
        </arr>
    </requestHandler>

    <requestHandler name="/update" class="solr.UpdateRequestHandler">
        <!-- See below for information on defining
             updateRequestProcessorChains that can be used by name
             on each Update Request
          -->
        <!--
           <lst name="defaults">
             <str name="update.chain">dedupe</str>
           </lst>
           -->
    </requestHandler>

    <!-- for back compat with clients using /update/json and /update/csv -->
    <requestHandler name="/update/json" class="solr.JsonUpdateRequestHandler">
        <lst name="defaults">
            <str name="stream.contentType">application/json</str>
        </lst>
    </requestHandler>
    <requestHandler name="/update/csv" class="solr.CSVRequestHandler">
        <lst name="defaults">
            <str name="stream.contentType">application/csv</str>
        </lst>
    </requestHandler>

    <!-- Solr Cell Update Request Handler

         http://wiki.apache.org/solr/ExtractingRequestHandler

      -->
    <requestHandler name="/update/extract"
                    startup="lazy"
                    class="solr.extraction.ExtractingRequestHandler">
        <lst name="defaults">
            <str name="lowernames">true</str>
            <str name="uprefix">ignored_</str>

            <!-- capture link hrefs but ignore div attributes -->
            <str name="captureAttr">true</str>
            <str name="fmap.a">links</str>
            <str name="fmap.div">ignored_</str>
        </lst>
    </requestHandler>


    <!-- Field Analysis Request Handler

         RequestHandler that provides much the same functionality as
         analysis.jsp. Provides the ability to specify multiple field
         types and field names in the same request and outputs
         index-time and query-time analysis for each of them.

         Request parameters are:
         analysis.fieldname - field name whose analyzers are to be used

         analysis.fieldtype - field type whose analyzers are to be used
         analysis.fieldvalue - text for index-time analysis
         q (or analysis.q) - text for query time analysis
         analysis.showmatch (true|false) - When set to true and when
             query analysis is performed, the produced tokens of the
             field value analysis will be marked as "matched" for every
             token that is produces by the query analysis
     -->
    <requestHandler name="/analysis/field"
                    startup="lazy"
                    class="solr.FieldAnalysisRequestHandler"/>


    <!-- Document Analysis Handler

         http://wiki.apache.org/solr/AnalysisRequestHandler

         An analysis handler that provides a breakdown of the analysis
         process of provided documents. This handler expects a (single)
         content stream with the following format:

         <docs>
           <doc>
             <field name="id">1</field>
             <field name="name">The Name</field>
             <field name="text">The Text Value</field>
           </doc>
           <doc>...</doc>
           <doc>...</doc>
           ...
         </docs>

      Note: Each document must contain a field which serves as the
      unique key. This key is used in the returned response to associate
      an analysis breakdown to the analyzed document.

      Like the FieldAnalysisRequestHandler, this handler also supports
      query analysis by sending either an "analysis.query" or "q"
      request parameter that holds the query text to be analyzed. It
      also supports the "analysis.showmatch" parameter which when set to
      true, all field tokens that match the query tokens will be marked
      as a "match".
    -->
    <requestHandler name="/analysis/document"
                    class="solr.DocumentAnalysisRequestHandler"
                    startup="lazy"/>

    <!-- Admin Handlers

         Admin Handlers - This will register all the standard admin
         RequestHandlers.
      -->
    <requestHandler name="/admin/"
                    class="solr.admin.AdminHandlers"/>
    <!-- This single handler is equivalent to the following... -->
    <!--
       <requestHandler name="/admin/luke"       class="solr.admin.LukeRequestHandler" />
       <requestHandler name="/admin/system"     class="solr.admin.SystemInfoHandler" />
       <requestHandler name="/admin/plugins"    class="solr.admin.PluginInfoHandler" />
       <requestHandler name="/admin/threads"    class="solr.admin.ThreadDumpHandler" />
       <requestHandler name="/admin/properties" class="solr.admin.PropertiesRequestHandler" />
       <requestHandler name="/admin/file"       class="solr.admin.ShowFileRequestHandler" >
      -->
    <!-- If you wish to hide files under ${solr.home}/conf, explicitly
         register the ShowFileRequestHandler using:
      -->
    <!--
       <requestHandler name="/admin/file"
                       class="solr.admin.ShowFileRequestHandler" >
         <lst name="invariants">
           <str name="hidden">synonyms.txt</str>
           <str name="hidden">anotherfile.txt</str>
         </lst>
       </requestHandler>
      -->

    <!-- ping/healthcheck -->
    <requestHandler name="/admin/ping" class="solr.PingRequestHandler">
        <lst name="invariants">
            <str name="q">solrpingquery</str>
        </lst>
        <lst name="defaults">
            <str name="echoParams">all</str>
        </lst>
        <!-- An optional feature of the PingRequestHandler is to configure the
             handler with a "healthcheckFile" which can be used to enable/disable
             the PingRequestHandler.
             relative paths are resolved against the data dir
          -->
        <!-- <str name="healthcheckFile">server-enabled.txt</str> -->
    </requestHandler>

    <!-- Echo the request contents back to the client -->
    <requestHandler name="/debug/dump" class="solr.DumpRequestHandler">
        <lst name="defaults">
            <str name="echoParams">explicit</str>
            <str name="echoHandler">true</str>
        </lst>
    </requestHandler>

    <!-- Solr Replication

         The SolrReplicationHandler supports replicating indexes from a
         "master" used for indexing and "slaves" used for queries.

         http://wiki.apache.org/solr/SolrReplication

         It is also necessary for SolrCloud to function (in Cloud mode, the
         replication handler is used to bulk transfer segments when nodes
         are added or need to recover).

         https://wiki.apache.org/solr/SolrCloud/
      -->
    <requestHandler name="/replication" class="solr.ReplicationHandler">
        <!--
           To enable simple master/slave replication, uncomment one of the
           sections below, depending on whether this solr instance should be
           the "master" or a "slave".  If this instance is a "slave" you will
           also need to fill in the masterUrl to point to a real machine.
        -->
        <!--
           <lst name="master">
             <str name="replicateAfter">commit</str>
             <str name="replicateAfter">startup</str>
             <str name="confFiles">schema.xml,stopwords.txt</str>
           </lst>
        -->
        <!--
           <lst name="slave">
             <str name="masterUrl">http://your-master-hostname:8983/solr</str>
             <str name="pollInterval">00:00:60</str>
           </lst>
        -->
    </requestHandler>

    <!-- Search Components

         Search components are registered to SolrCore and used by
         instances of SearchHandler (which can access them by name)

         By default, the following components are available:

         <searchComponent name="query"     class="solr.QueryComponent" />
         <searchComponent name="facet"     class="solr.FacetComponent" />
         <searchComponent name="mlt"       class="solr.MoreLikeThisComponent" />
         <searchComponent name="highlight" class="solr.HighlightComponent" />
         <searchComponent name="stats"     class="solr.StatsComponent" />
         <searchComponent name="debug"     class="solr.DebugComponent" />

         Default configuration in a requestHandler would look like:

         <arr name="components">
           <str>query</str>
           <str>facet</str>
           <str>mlt</str>
           <str>highlight</str>
           <str>stats</str>
           <str>debug</str>
         </arr>

         If you register a searchComponent to one of the standard names,
         that will be used instead of the default.

         To insert components before or after the 'standard' components, use:

         <arr name="first-components">
           <str>myFirstComponentName</str>
         </arr>

         <arr name="last-components">
           <str>myLastComponentName</str>
         </arr>

         NOTE: The component registered with the name "debug" will
         always be executed after the "last-components"

       -->

    <!-- Spell Check

         The spell check component can return a list of alternative spelling
         suggestions.

         http://wiki.apache.org/solr/SpellCheckComponent
      -->
    <searchComponent name="spellcheck" class="solr.SpellCheckComponent">

        <str name="queryAnalyzerFieldType">text_general</str>

        <!-- Multiple "Spell Checkers" can be declared and used by this
             component
          -->

        <!-- a spellchecker built from a field of the main index -->
        <lst name="spellchecker">
            <str name="name">default</str>
            <str name="field">text</str>
            <str name="classname">solr.DirectSolrSpellChecker</str>
            <!-- the spellcheck distance measure used, the default is the internal levenshtein -->
            <str name="distanceMeasure">internal</str>
            <!-- minimum accuracy needed to be considered a valid spellcheck suggestion -->
            <float name="accuracy">0.5</float>
            <!-- the maximum #edits we consider when enumerating terms: can be 1 or 2 -->
            <int name="maxEdits">2</int>
            <!-- the minimum shared prefix when enumerating terms -->
            <int name="minPrefix">1</int>
            <!-- maximum number of inspections per result. -->
            <int name="maxInspections">5</int>
            <!-- minimum length of a query term to be considered for correction -->
            <int name="minQueryLength">4</int>
            <!-- maximum threshold of documents a query term can appear to be considered for correction -->
            <float name="maxQueryFrequency">0.01</float>
            <!-- uncomment this to require suggestions to occur in 1% of the documents
                <float name="thresholdTokenFrequency">.01</float>
            -->
        </lst>

        <!-- a spellchecker that can break or combine words.  See "/spell" handler below for usage -->
        <lst name="spellchecker">
            <str name="name">wordbreak</str>
            <str name="classname">solr.WordBreakSolrSpellChecker</str>
            <str name="field">name</str>
            <str name="combineWords">true</str>
            <str name="breakWords">true</str>
            <int name="maxChanges">10</int>
        </lst>

        <!-- a spellchecker that uses a different distance measure -->
        <!--
           <lst name="spellchecker">
             <str name="name">jarowinkler</str>
             <str name="field">spell</str>
             <str name="classname">solr.DirectSolrSpellChecker</str>
             <str name="distanceMeasure">
               org.apache.lucene.search.spell.JaroWinklerDistance
             </str>
           </lst>
         -->

        <!-- a spellchecker that use an alternate comparator

             comparatorClass be one of:
              1. score (default)
              2. freq (Frequency first, then score)
              3. A fully qualified class name
          -->
        <!--
           <lst name="spellchecker">
             <str name="name">freq</str>
             <str name="field">lowerfilt</str>
             <str name="classname">solr.DirectSolrSpellChecker</str>
             <str name="comparatorClass">freq</str>
          -->

        <!-- A spellchecker that reads the list of words from a file -->
        <!--
           <lst name="spellchecker">
             <str name="classname">solr.FileBasedSpellChecker</str>
             <str name="name">file</str>
             <str name="sourceLocation">spellings.txt</str>
             <str name="characterEncoding">UTF-8</str>
             <str name="spellcheckIndexDir">spellcheckerFile</str>
           </lst>
          -->
    </searchComponent>

    <!-- A request handler for demonstrating the spellcheck component.

         NOTE: This is purely as an example.  The whole purpose of the
         SpellCheckComponent is to hook it into the request handler that
         handles your normal user queries so that a separate request is
         not needed to get suggestions.

         IN OTHER WORDS, THERE IS REALLY GOOD CHANCE THE SETUP BELOW IS
         NOT WHAT YOU WANT FOR YOUR PRODUCTION SYSTEM!

         See http://wiki.apache.org/solr/SpellCheckComponent for details
         on the request parameters.
      -->
    <requestHandler name="/spell" class="solr.SearchHandler" startup="lazy">
        <lst name="defaults">
            <str name="df">text</str>
            <!-- Solr will use suggestions from both the 'default' spellchecker
                 and from the 'wordbreak' spellchecker and combine them.
                 collations (re-written queries) can include a combination of
                 corrections from both spellcheckers -->
            <str name="spellcheck.dictionary">default</str>
            <str name="spellcheck.dictionary">wordbreak</str>
            <str name="spellcheck">on</str>
            <str name="spellcheck.extendedResults">true</str>
            <str name="spellcheck.count">10</str>
            <str name="spellcheck.alternativeTermCount">5</str>
            <str name="spellcheck.maxResultsForSuggest">5</str>
            <str name="spellcheck.collate">true</str>
            <str name="spellcheck.collateExtendedResults">true</str>
            <str name="spellcheck.maxCollationTries">10</str>
            <str name="spellcheck.maxCollations">5</str>
        </lst>
        <arr name="last-components">
            <str>spellcheck</str>
        </arr>
    </requestHandler>

    <!-- Term Vector Component

         http://wiki.apache.org/solr/TermVectorComponent
      -->
    <searchComponent name="tvComponent" class="solr.TermVectorComponent"/>

    <!-- A request handler for demonstrating the term vector component

         This is purely as an example.

         In reality you will likely want to add the component to your
         already specified request handlers.
      -->
    <requestHandler name="/tvrh" class="solr.SearchHandler" startup="lazy">
        <lst name="defaults">
            <str name="df">text</str>
            <bool name="tv">true</bool>
        </lst>
        <arr name="last-components">
            <str>tvComponent</str>
        </arr>
    </requestHandler>

    <!-- Clustering Component

         http://wiki.apache.org/solr/ClusteringComponent

         You'll need to set the solr.clustering.enabled system property
         when running solr to run with clustering enabled:

              java -Dsolr.clustering.enabled=true -jar start.jar

      -->
    <searchComponent name="clustering"
                     enable="${solr.clustering.enabled:false}"
                     class="solr.clustering.ClusteringComponent">
        <!-- Declare an engine -->
        <lst name="engine">
            <!-- The name, only one can be named "default" -->
            <str name="name">default</str>

            <!-- Class name of Carrot2 clustering algorithm.

                 Currently available algorithms are:

                 * org.carrot2.clustering.lingo.LingoClusteringAlgorithm
                 * org.carrot2.clustering.stc.STCClusteringAlgorithm
                 * org.carrot2.clustering.kmeans.BisectingKMeansClusteringAlgorithm

                 See http://project.carrot2.org/algorithms.html for the
                 algorithm's characteristics.
              -->
            <str name="carrot.algorithm">org.carrot2.clustering.lingo.LingoClusteringAlgorithm</str>

            <!-- Overriding values for Carrot2 default algorithm attributes.

                 For a description of all available attributes, see:
                 http://download.carrot2.org/stable/manual/#chapter.components.
                 Use attribute key as name attribute of str elements
                 below. These can be further overridden for individual
                 requests by specifying attribute key as request parameter
                 name and attribute value as parameter value.
              -->
            <str name="LingoClusteringAlgorithm.desiredClusterCountBase">20</str>

            <!-- Location of Carrot2 lexical resources.

                 A directory from which to load Carrot2-specific stop words
                 and stop labels. Absolute or relative to Solr config directory.
                 If a specific resource (e.g. stopwords.en) is present in the
                 specified dir, it will completely override the corresponding
                 default one that ships with Carrot2.

                 For an overview of Carrot2 lexical resources, see:
                 http://download.carrot2.org/head/manual/#chapter.lexical-resources
              -->
            <str name="carrot.lexicalResourcesDir">clustering/carrot2</str>

            <!-- The language to assume for the documents.

                 For a list of allowed values, see:
                 http://download.carrot2.org/stable/manual/#section.attribute.lingo.MultilingualClustering.defaultLanguage
             -->
            <str name="MultilingualClustering.defaultLanguage">ENGLISH</str>
        </lst>
        <lst name="engine">
            <str name="name">stc</str>
            <str name="carrot.algorithm">org.carrot2.clustering.stc.STCClusteringAlgorithm</str>
        </lst>
    </searchComponent>

    <!-- A request handler for demonstrating the clustering component

         This is purely as an example.

         In reality you will likely want to add the component to your
         already specified request handlers.
      -->
    <requestHandler name="/clustering"
                    startup="lazy"
                    enable="${solr.clustering.enabled:false}"
                    class="solr.SearchHandler">
        <lst name="defaults">
            <bool name="clustering">true</bool>
            <str name="clustering.engine">default</str>
            <bool name="clustering.results">true</bool>
            <!-- The title field -->
            <str name="carrot.title">name</str>
            <str name="carrot.url">id</str>
            <!-- The field to cluster on -->
            <str name="carrot.snippet">features</str>
            <!-- produce summaries -->
            <bool name="carrot.produceSummary">true</bool>
            <!-- the maximum number of labels per cluster -->
            <!--<int name="carrot.numDescriptions">5</int>-->
            <!-- produce sub clusters -->
            <bool name="carrot.outputSubClusters">false</bool>

            <str name="defType">edismax</str>
            <str name="qf">
                text^0.5 features^1.0 name^1.2 sku^1.5 id^10.0 manu^1.1 cat^1.4
            </str>
            <str name="q.alt">*:*</str>
            <str name="rows">10</str>
            <str name="fl">*,score</str>
        </lst>
        <arr name="last-components">
            <str>clustering</str>
        </arr>
    </requestHandler>

    <!-- Terms Component

         http://wiki.apache.org/solr/TermsComponent

         A component to return terms and document frequency of those
         terms
      -->
    <searchComponent name="terms" class="solr.TermsComponent"/>

    <!-- A request handler for demonstrating the terms component -->
    <requestHandler name="/terms" class="solr.SearchHandler" startup="lazy">
        <lst name="defaults">
            <bool name="terms">true</bool>
            <bool name="distrib">false</bool>
        </lst>
        <arr name="components">
            <str>terms</str>
        </arr>
    </requestHandler>


    <!-- Query Elevation Component

         http://wiki.apache.org/solr/QueryElevationComponent

         a search component that enables you to configure the top
         results for a given query regardless of the normal lucene
         scoring.
      -->
    <searchComponent name="elevator" class="solr.QueryElevationComponent">
        <!-- pick a fieldType to analyze queries -->
        <str name="queryFieldType">string</str>
        <str name="config-file">elevate.xml</str>
    </searchComponent>

    <!-- A request handler for demonstrating the elevator component -->
    <requestHandler name="/elevate" class="solr.SearchHandler" startup="lazy">
        <lst name="defaults">
            <str name="echoParams">explicit</str>
            <str name="df">text</str>
        </lst>
        <arr name="last-components">
            <str>elevator</str>
        </arr>
    </requestHandler>

    <!-- Highlighting Component

         http://wiki.apache.org/solr/HighlightingParameters
      -->
    <searchComponent class="solr.HighlightComponent" name="highlight">
        <highlighting>
            <!-- Configure the standard fragmenter -->
            <!-- This could most likely be commented out in the "default" case -->
            <fragmenter name="gap"
                        default="true"
                        class="solr.highlight.GapFragmenter">
                <lst name="defaults">
                    <int name="hl.fragsize">100</int>
                </lst>
            </fragmenter>

            <!-- A regular-expression-based fragmenter
                 (for sentence extraction)
              -->
            <fragmenter name="regex"
                        class="solr.highlight.RegexFragmenter">
                <lst name="defaults">
                    <!-- slightly smaller fragsizes work better because of slop -->
                    <int name="hl.fragsize">70</int>
                    <!-- allow 50% slop on fragment sizes -->
                    <float name="hl.regex.slop">0.5</float>
                    <!-- a basic sentence pattern -->
                    <str name="hl.regex.pattern">[-\w ,/\n\&quot;&apos;]{20,200}</str>
                </lst>
            </fragmenter>

            <!-- Configure the standard formatter -->
            <formatter name="html"
                       default="true"
                       class="solr.highlight.HtmlFormatter">
                <lst name="defaults">
                    <str name="hl.simple.pre"><![CDATA[<em>]]></str>
                    <str name="hl.simple.post"><![CDATA[</em>]]></str>
                </lst>
            </formatter>

            <!-- Configure the standard encoder -->
            <encoder name="html"
                     class="solr.highlight.HtmlEncoder"/>

            <!-- Configure the standard fragListBuilder -->
            <fragListBuilder name="simple"
                             class="solr.highlight.SimpleFragListBuilder"/>

            <!-- Configure the single fragListBuilder -->
            <fragListBuilder name="single"
                             class="solr.highlight.SingleFragListBuilder"/>

            <!-- Configure the weighted fragListBuilder -->
            <fragListBuilder name="weighted"
                             default="true"
                             class="solr.highlight.WeightedFragListBuilder"/>

            <!-- default tag FragmentsBuilder -->
            <fragmentsBuilder name="default"
                              default="true"
                              class="solr.highlight.ScoreOrderFragmentsBuilder">
                <!--
                <lst name="defaults">
                  <str name="hl.multiValuedSeparatorChar">/</str>
                </lst>
                -->
            </fragmentsBuilder>

            <!-- multi-colored tag FragmentsBuilder -->
            <fragmentsBuilder name="colored"
                              class="solr.highlight.ScoreOrderFragmentsBuilder">
                <lst name="defaults">
                    <str name="hl.tag.pre"><![CDATA[
               <b style="background:yellow">,<b style="background:lawgreen">,
               <b style="background:aquamarine">,<b style="background:magenta">,
               <b style="background:palegreen">,<b style="background:coral">,
               <b style="background:wheat">,<b style="background:khaki">,
               <b style="background:lime">,<b style="background:deepskyblue">]]></str>
                    <str name="hl.tag.post"><![CDATA[</b>]]></str>
                </lst>
            </fragmentsBuilder>

            <boundaryScanner name="default"
                             default="true"
                             class="solr.highlight.SimpleBoundaryScanner">
                <lst name="defaults">
                    <str name="hl.bs.maxScan">10</str>
                    <str name="hl.bs.chars">.,!? &#9;&#10;&#13;</str>
                </lst>
            </boundaryScanner>

            <boundaryScanner name="breakIterator"
                             class="solr.highlight.BreakIteratorBoundaryScanner">
                <lst name="defaults">
                    <!-- type should be one of CHARACTER, WORD(default), LINE and SENTENCE -->
                    <str name="hl.bs.type">WORD</str>
                    <!-- language and country are used when constructing Locale object.  -->
                    <!-- And the Locale object will be used when getting instance of BreakIterator -->
                    <str name="hl.bs.language">en</str>
                    <str name="hl.bs.country">US</str>
                </lst>
            </boundaryScanner>
        </highlighting>
    </searchComponent>

    <!-- Update Processors

         Chains of Update Processor Factories for dealing with Update
         Requests can be declared, and then used by name in Update
         Request Processors

         http://wiki.apache.org/solr/UpdateRequestProcessor

      -->
    <!-- Deduplication

         An example dedup update processor that creates the "id" field
         on the fly based on the hash code of some other fields.  This
         example has overwriteDupes set to false since we are using the
         id field as the signatureField and Solr will maintain
         uniqueness based on that anyway.

      -->
    <!--
       <updateRequestProcessorChain name="dedupe">
         <processor class="solr.processor.SignatureUpdateProcessorFactory">
           <bool name="enabled">true</bool>
           <str name="signatureField">id</str>
           <bool name="overwriteDupes">false</bool>
           <str name="fields">name,features,cat</str>
           <str name="signatureClass">solr.processor.Lookup3Signature</str>
         </processor>
         <processor class="solr.LogUpdateProcessorFactory" />
         <processor class="solr.RunUpdateProcessorFactory" />
       </updateRequestProcessorChain>
      -->

    <!-- Language identification

         This example update chain identifies the language of the incoming
         documents using the langid contrib. The detected language is
         written to field language_s. No field name mapping is done.
         The fields used for detection are text, title, subject and description,
         making this example suitable for detecting languages form full-text
         rich documents injected via ExtractingRequestHandler.
         See more about langId at http://wiki.apache.org/solr/LanguageDetection
      -->
    <!--
     <updateRequestProcessorChain name="langid">
       <processor class="org.apache.solr.update.processor.TikaLanguageIdentifierUpdateProcessorFactory">
         <str name="langid.fl">text,title,subject,description</str>
         <str name="langid.langField">language_s</str>
         <str name="langid.fallback">en</str>
       </processor>
       <processor class="solr.LogUpdateProcessorFactory" />
       <processor class="solr.RunUpdateProcessorFactory" />
     </updateRequestProcessorChain>
    -->

    <!-- Script update processor

      This example hooks in an update processor implemented using JavaScript.

      See more about the script update processor at http://wiki.apache.org/solr/ScriptUpdateProcessor
    -->
    <!--
      <updateRequestProcessorChain name="script">
        <processor class="solr.StatelessScriptUpdateProcessorFactory">
          <str name="script">update-script.js</str>
          <lst name="params">
            <str name="config_param">example config parameter</str>
          </lst>
        </processor>
        <processor class="solr.RunUpdateProcessorFactory" />
      </updateRequestProcessorChain>
    -->

    <!-- Response Writers

         http://wiki.apache.org/solr/QueryResponseWriter

         Request responses will be written using the writer specified by
         the 'wt' request parameter matching the name of a registered
         writer.

         The "default" writer is the default and will be used if 'wt' is
         not specified in the request.
      -->
    <!-- The following response writers are implicitly configured unless
         overridden...
      -->
    <!--
       <queryResponseWriter name="xml"
                            default="true"
                            class="solr.XMLResponseWriter" />
       <queryResponseWriter name="json" class="solr.JSONResponseWriter"/>
       <queryResponseWriter name="python" class="solr.PythonResponseWriter"/>
       <queryResponseWriter name="ruby" class="solr.RubyResponseWriter"/>
       <queryResponseWriter name="php" class="solr.PHPResponseWriter"/>
       <queryResponseWriter name="phps" class="solr.PHPSerializedResponseWriter"/>
       <queryResponseWriter name="csv" class="solr.CSVResponseWriter"/>
       <queryResponseWriter name="schema.xml" class="solr.SchemaXmlResponseWriter"/>
      -->

    <queryResponseWriter name="json" class="solr.JSONResponseWriter">
        <!-- For the purposes of the tutorial, JSON responses are written as
         plain text so that they are easy to read in *any* browser.
         If you expect a MIME type of "application/json" just remove this override.
        -->
        <str name="content-type">text/plain; charset=UTF-8</str>
    </queryResponseWriter>

    <!--
       Custom response writers can be declared as needed...
      -->
    <queryResponseWriter name="velocity" class="solr.VelocityResponseWriter" startup="lazy"/>


    <!-- XSLT response writer transforms the XML output by any xslt file found
         in Solr's conf/xslt directory.  Changes to xslt files are checked for
         every xsltCacheLifetimeSeconds.
      -->
    <queryResponseWriter name="xslt" class="solr.XSLTResponseWriter">
        <int name="xsltCacheLifetimeSeconds">5</int>
    </queryResponseWriter>

    <!-- Query Parsers

         http://wiki.apache.org/solr/SolrQuerySyntax

         Multiple QParserPlugins can be registered by name, and then
         used in either the "defType" param for the QueryComponent (used
         by SearchHandler) or in LocalParams
      -->
    <!-- example of registering a query parser -->
    <!--
       <queryParser name="myparser" class="com.mycompany.MyQParserPlugin"/>
      -->

    <!-- Function Parsers

         http://wiki.apache.org/solr/FunctionQuery

         Multiple ValueSourceParsers can be registered by name, and then
         used as function names when using the "func" QParser.
      -->
    <!-- example of registering a custom function parser  -->
    <!--
       <valueSourceParser name="myfunc"
                          class="com.mycompany.MyValueSourceParser" />
      -->


    <!-- Document Transformers
         http://wiki.apache.org/solr/DocTransformers
      -->
    <!--
       Could be something like:
       <transformer name="db" class="com.mycompany.LoadFromDatabaseTransformer" >
         <int name="connection">jdbc://....</int>
       </transformer>

       To add a constant value to all docs, use:
       <transformer name="mytrans2" class="org.apache.solr.response.transform.ValueAugmenterFactory" >
         <int name="value">5</int>
       </transformer>

       If you want the user to still be able to change it with _value:something_ use this:
       <transformer name="mytrans3" class="org.apache.solr.response.transform.ValueAugmenterFactory" >
         <double name="defaultValue">5</double>
       </transformer>

        If you are using the QueryElevationComponent, you may wish to mark documents that get boosted.  The
        EditorialMarkerFactory will do exactly that:
       <transformer name="qecBooster" class="org.apache.solr.response.transform.EditorialMarkerFactory" />
      -->


    <!-- Legacy config for the admin interface -->
    <admin>
        <defaultQuery>*:*</defaultQuery>
    </admin>

</config>
